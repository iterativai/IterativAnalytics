# azure-pipelines.yml - Azure DevOps CI/CD Pipeline
trigger:
  branches:
    include:
    - main
    - develop

variables:
  azureSubscription: 'Azure-Service-Connection'
  resourceGroup: 'rg-iterativ-analytics'
  appName: 'iterativ-analytics'
  containerRegistry: 'iterativregistry.azurecr.io'
  imageRepository: 'iterativ-analytics'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'

stages:
- stage: Build
  displayName: Build and Test
  jobs:
  - job: Build
    displayName: Build
    pool:
      vmImage: ubuntu-latest
    
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x'
      displayName: 'Install Node.js'

    - script: |
        npm ci
        npm run lint
        npm run type-check
        npm run test
      displayName: 'Install dependencies and run tests'

    - script: |
        npm run build
      displayName: 'Build application'

    - task: Docker@2
      displayName: 'Build Docker image'
      inputs:
        containerRegistry: '$(containerRegistry)'
        repository: '$(imageRepository)'
        command: 'build'
        Dockerfile: '$(dockerfilePath)'
        tags: |
          $(tag)
          latest

    - task: Docker@2
      displayName: 'Push Docker image'
      inputs:
        containerRegistry: '$(containerRegistry)'
        repository: '$(imageRepository)'
        command: 'push'
        tags: |
          $(tag)
          latest

- stage: DeployToStaging
  displayName: Deploy to Staging
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  
  jobs:
  - deployment: DeployStaging
    displayName: Deploy to Staging
    pool:
      vmImage: ubuntu-latest
    environment: 'staging'
    
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureWebAppContainer@1
            displayName: 'Deploy to Azure Web App'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appName: '$(appName)-staging'
              containers: '$(containerRegistry)/$(imageRepository):$(tag)'

          - task: AzureCLI@2
            displayName: 'Run Database Migrations'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az webapp ssh --name $(appName)-staging --resource-group $(resourceGroup) --timeout 300 << 'EOF'
                cd /home/site/wwwroot
                npm run migrate
                EOF

          - task: AzureCLI@2
            displayName: 'Health Check'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                sleep 30
                curl -f https://$(appName)-staging.azurewebsites.net/health

- stage: DeployToProduction
  displayName: Deploy to Production
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  
  jobs:
  - deployment: DeployProduction
    displayName: Deploy to Production
    pool:
      vmImage: ubuntu-latest
    environment: 'production'
    
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureWebAppContainer@1
            displayName: 'Deploy to Azure Web App'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appName: '$(appName)'
              containers: '$(containerRegistry)/$(imageRepository):$(tag)'
              deployToSlotOrASE: true
              slotName: 'staging'

          - task: AzureCLI@2
            displayName: 'Run Database Migrations'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az webapp ssh --name $(appName) --resource-group $(resourceGroup) --slot staging << 'EOF'
                cd /home/site/wwwroot
                npm run migrate
                EOF

          - task: AzureCLI@2
            displayName: 'Smoke Tests'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                sleep 30
                curl -f https://$(appName)-staging.azurewebsites.net/health
                curl -f https://$(appName)-staging.azurewebsites.net/api/health

          - task: AzureAppServiceManage@0
            displayName: 'Swap Staging to Production'
            inputs:
              azureSubscription: '$(azureSubscription)'
              action: 'Swap Slots'
              webAppName: '$(appName)'
              resourceGroupName: '$(resourceGroup)'
              sourceSlot: 'staging'

          - task: AzureCLI@2
            displayName: 'Production Health Check'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                sleep 10
                curl -f https://$(appName).azurewebsites.net/health

---

# bicep/main.bicep - Infrastructure as Code with Bicep
@description('Location for all resources')
param location string = resourceGroup().location

@description('Base name for all resources')
param baseName string = 'iterativ-analytics'

@description('Environment (dev, staging, prod)')
param environment string = 'prod'

@description('App Service SKU')
param appServiceSku string = 'B1'

@description('Database SKU')
param databaseSku string = 'Standard_B1ms'

@description('Redis SKU')
param redisSku string = 'Basic'

@description('Redis capacity')
param redisCapacity int = 0

var resourceNames = {
  appServicePlan: '${baseName}-plan-${environment}'
  appService: '${baseName}-${environment}'
  database: '${baseName}-db-${environment}'
  redis: '${baseName}-cache-${environment}'
  storage: '${baseName}storage${environment}${uniqueString(resourceGroup().id)}'
  keyVault: '${baseName}-kv-${environment}-${uniqueString(resourceGroup().id)}'
  openai: '${baseName}-openai-${environment}'
  insights: '${baseName}-insights-${environment}'
  containerRegistry: '${baseName}registry${environment}'
}

// App Service Plan
resource appServicePlan 'Microsoft.Web/serverfarms@2022-03-01' = {
  name: resourceNames.appServicePlan
  location: location
  sku: {
    name: appServiceSku
  }
  kind: 'linux'
  properties: {
    reserved: true
  }
}

// Container Registry
resource containerRegistry 'Microsoft.ContainerRegistry/registries@2022-02-01-preview' = {
  name: resourceNames.containerRegistry
  location: location
  sku: {
    name: 'Basic'
  }
  properties: {
    adminUserEnabled: true
  }
}

// PostgreSQL Flexible Server
resource postgresServer 'Microsoft.DBforPostgreSQL/flexibleServers@2022-12-01' = {
  name: resourceNames.database
  location: location
  sku: {
    name: databaseSku
    tier: 'Burstable'
  }
  properties: {
    administratorLogin: 'iterativadmin'
    administratorLoginPassword: uniqueString(resourceGroup().id, baseName)
    version: '14'
    storage: {
      storageSizeGB: 32
    }
    backup: {
      backupRetentionDays: 7
      geoRedundantBackup: 'Disabled'
    }
    highAvailability: {
      mode: 'Disabled'
    }
  }
}

// PostgreSQL Database
resource postgresDatabase 'Microsoft.DBforPostgreSQL/flexibleServers/databases@2022-12-01' = {
  parent: postgresServer
  name: 'iterativ_analytics'
}

// PostgreSQL Firewall Rule for Azure Services
resource postgresFirewallRule 'Microsoft.DBforPostgreSQL/flexibleServers/firewallRules@2022-12-01' = {
  parent: postgresServer
  name: 'AllowAzureServices'
  properties: {
    startIpAddress: '0.0.0.0'
    endIpAddress: '0.0.0.0'
  }
}

// Redis Cache
resource redisCache 'Microsoft.Cache/redis@2022-06-01' = {
  name: resourceNames.redis
  location: location
  properties: {
    sku: {
      name: redisSku
      family: 'C'
      capacity: redisCapacity
    }
    enableNonSslPort: false
    minimumTlsVersion: '1.2'
    redisConfiguration: {
      'maxmemory-policy': 'allkeys-lru'
    }
  }
}

// Storage Account
resource storageAccount 'Microsoft.Storage/storageAccounts@2022-09-01' = {
  name: resourceNames.storage
  location: location
  sku: {
    name: 'Standard_LRS'
  }
  kind: 'StorageV2'
  properties: {
    supportsHttpsTrafficOnly: true
    minimumTlsVersion: 'TLS1_2'
    allowBlobPublicAccess: true
    accessTier: 'Hot'
  }
}

// Blob Container
resource blobContainer 'Microsoft.Storage/storageAccounts/blobServices/containers@2022-09-01' = {
  name: '${storageAccount.name}/default/documents'
  properties: {
    publicAccess: 'Blob'
  }
}

// Key Vault
resource keyVault 'Microsoft.KeyVault/vaults@2022-07-01' = {
  name: resourceNames.keyVault
  location: location
  properties: {
    sku: {
      family: 'A'
      name: 'standard'
    }
    tenantId: subscription().tenantId
    enabledForDeployment: false
    enabledForTemplateDeployment: true
    enabledForDiskEncryption: false
    accessPolicies: []
    enableRbacAuthorization: true
  }
}

// OpenAI Service
resource openaiService 'Microsoft.CognitiveServices/accounts@2023-05-01' = {
  name: resourceNames.openai
  location: 'East US' // OpenAI is only available in specific regions
  sku: {
    name: 'S0'
  }
  kind: 'OpenAI'
  properties: {
    apiProperties: {
      statisticsEnabled: false
    }
  }
}

// OpenAI Deployments
resource gpt4Deployment 'Microsoft.CognitiveServices/accounts/deployments@2023-05-01' = {
  parent: openaiService
  name: 'gpt-4'
  properties: {
    model: {
      format: 'OpenAI'
      name: 'gpt-4'
      version: '0613'
    }
    scaleSettings: {
      scaleType: 'Standard'
    }
  }
}

resource embeddingDeployment 'Microsoft.CognitiveServices/accounts/deployments@2023-05-01' = {
  parent: openaiService
  name: 'text-embedding-ada-002'
  dependsOn: [gpt4Deployment]
  properties: {
    model: {
      format: 'OpenAI'
      name: 'text-embedding-ada-002'
      version: '2'
    }
    scaleSettings: {
      scaleType: 'Standard'
    }
  }
}

// Application Insights
resource applicationInsights 'Microsoft.Insights/components@2020-02-02' = {
  name: resourceNames.insights
  location: location
  kind: 'web'
  properties: {
    Application_Type: 'web'
    Request_Source: 'rest'
  }
}

// App Service
resource appService 'Microsoft.Web/sites@2022-03-01' = {
  name: resourceNames.appService
  location: location
  identity: {
    type: 'SystemAssigned'
  }
  properties: {
    serverFarmId: appServicePlan.id
    siteConfig: {
      linuxFxVersion: 'DOCKER|${containerRegistry.name}.azurecr.io/${baseName}:latest'
      alwaysOn: true
      ftpsState: 'Disabled'
      minTlsVersion: '1.2'
      appSettings: [
        {
          name: 'NODE_ENV'
          value: 'production'
        }
        {
          name: 'WEBSITES_ENABLE_APP_SERVICE_STORAGE'
          value: 'false'
        }
        {
          name: 'AZURE_KEY_VAULT_NAME'
          value: keyVault.name
        }
        {
          name: 'APPINSIGHTS_INSTRUMENTATIONKEY'
          value: applicationInsights.properties.InstrumentationKey
        }
        {
          name: 'APPLICATIONINSIGHTS_CONNECTION_STRING'
          value: applicationInsights.properties.ConnectionString
        }
      ]
    }
    httpsOnly: true
  }
}

// App Service Staging Slot
resource appServiceStagingSlot 'Microsoft.Web/sites/slots@2022-03-01' = {
  parent: appService
  name: 'staging'
  location: location
  identity: {
    type: 'SystemAssigned'
  }
  properties: {
    serverFarmId: appServicePlan.id
    siteConfig: {
      linuxFxVersion: 'DOCKER|${containerRegistry.name}.azurecr.io/${baseName}:latest'
      alwaysOn: true
      ftpsState: 'Disabled'
      minTlsVersion: '1.2'
    }
    httpsOnly: true
  }
}

// Key Vault Access Policy for App Service
resource keyVaultAccessPolicy 'Microsoft.KeyVault/vaults/accessPolicies@2022-07-01' = {
  parent: keyVault
  name: 'add'
  properties: {
    accessPolicies: [
      {
        tenantId: subscription().tenantId
        objectId: appService.identity.principalId
        permissions: {
          secrets: ['get', 'list']
        }
      }
      {
        tenantId: subscription().tenantId
        objectId: appServiceStagingSlot.identity.principalId
        permissions: {
          secrets: ['get', 'list']
        }
      }
    ]
  }
}

// Key Vault Secrets
resource dbConnectionSecret 'Microsoft.KeyVault/vaults/secrets@2022-07-01' = {
  parent: keyVault
  name: 'database-url'
  properties: {
    value: 'postgresql://${postgresServer.properties.administratorLogin}:${uniqueString(resourceGroup().id, baseName)}@${postgresServer.properties.fullyQualifiedDomainName}:5432/${postgresDatabase.name}?sslmode=require'
  }
}

resource redisConnectionSecret 'Microsoft.KeyVault/vaults/secrets@2022-07-01' = {
  parent: keyVault
  name: 'redis-url'
  properties: {
    value: 'rediss://:${redisCache.listKeys().primaryKey}@${redisCache.properties.hostName}:${redisCache.properties.sslPort}'
  }
}

resource storageConnectionSecret 'Microsoft.KeyVault/vaults/secrets@2022-07-01' = {
  parent: keyVault
  name: 'storage-connection'
  properties: {
    value: 'DefaultEndpointsProtocol=https;AccountName=${storageAccount.name};AccountKey=${storageAccount.listKeys().keys[0].value};EndpointSuffix=core.windows.net'
  }
}

resource openaiEndpointSecret 'Microsoft.KeyVault/vaults/secrets@2022-07-01' = {
  parent: keyVault
  name: 'openai-endpoint'
  properties: {
    value: openaiService.properties.endpoint
  }
}

resource openaiKeySecret 'Microsoft.KeyVault/vaults/secrets@2022-07-01' = {
  parent: keyVault
  name: 'openai-key'
  properties: {
    value: openaiService.listKeys().key1
  }
}

// Output values
output appServiceName string = appService.name
output appServiceUrl string = 'https://${appService.properties.defaultHostName}'
output containerRegistryName string = containerRegistry.name
output keyVaultName string = keyVault.name
output databaseServer string = postgresServer.properties.fullyQualifiedDomainName
output openaiEndpoint string = openaiService.properties.endpoint

---

# package.json - Updated with Azure dependencies
{
  "name": "iterativ-analytics",
  "version": "1.0.0",
  "description": "Financial Intelligence for African Startups - Azure Edition",
  "main": "index.js",
  "scripts": {
    "dev": "tsx server/index.ts",
    "build": "tsc && vite build",
    "start": "node server/index.js",
    "test": "vitest",
    "lint": "eslint . --ext .ts,.tsx,.js,.jsx",
    "type-check": "tsc --noEmit",
    "migrate": "tsx scripts/migrate.ts",
    "azure:setup": "./scripts/azure-setup.sh",
    "azure:deploy": "./scripts/azure-deploy.sh",
    "azure:migrate": "./scripts/azure-migrate-db.sh",
    "deploy:bicep": "az deployment group create --resource-group rg-iterativ-analytics --template-file bicep/main.bicep"
  },
  "dependencies": {
    "@azure/identity": "^3.4.2",
    "@azure/keyvault-secrets": "^4.7.0",
    "@azure/storage-blob": "^12.17.0",
    "@azure/openai": "^1.0.0-beta.7",
    "applicationinsights": "^2.9.1",
    "express": "^4.18.2",
    "drizzle-orm": "^0.35.3",
    "pg": "^8.11.3",
    "redis": "^4.6.10",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "typescript": "^5.6.2",
    "vite": "^5.4.8",
    "framer-motion": "^11.11.17",
    "tailwindcss": "^3.4.13",
    "lucide-react": "^0.460.0",
    "firebase": "^10.14.0",
    "@tanstack/react-query": "^5.59.0",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "tailwind-merge": "^2.5.4"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^22.7.4",
    "@types/pg": "^8.10.9",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.3",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.47",
    "tsx": "^4.6.2",
    "eslint": "^8.57.0",
    "vitest": "^1.6.0"
  }
}

---

# server/index.ts - Updated main server file for Azure
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import compression from 'compression';
import { resolve } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Azure imports
import { AzureConfig } from './azure/config';
import { azureMonitoring } from './azure/monitoring';
import { azureDb } from './azure/database';
import { azureCache } from './azure/cache';

// Route imports
import azureRoutes from './routes/azure-routes';
import { errorHandler, notFoundHandler } from './middleware/errorHandlers';
import { logger } from './utils/logger';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const PORT = process.env.PORT || 8080; // Azure App Service uses port 8080
const NODE_ENV = process.env.NODE_ENV || 'development';

// Initialize Azure services
const initializeAzureServices = async () => {
  try {
    logger.info('Initializing Azure services...');
    
    // Initialize Azure configuration
    AzureConfig.getInstance();
    
    // Test database connection
    const dbHealthy = await azureDb.testConnection();
    if (!dbHealthy) {
      throw new Error('Database connection failed');
    }
    
    logger.info('Azure services initialized successfully');
  } catch (error) {
    logger.error('Failed to initialize Azure services:', error);
    azureMonitoring.trackException(error as Error);
    process.exit(1);
  }
};

// Trust proxy for proper IP detection behind Azure Load Balancer
app.set('trust proxy', 1);

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:", "blob:"],
      scriptSrc: ["'self'", ...(NODE_ENV === 'development' ? ["'unsafe-eval'"] : [])],
      connectSrc: [
        "'self'", 
        "https://*.openai.azure.com",
        "https://identitytoolkit.googleapis.com",
        "https://securetoken.googleapis.com",
        ...(NODE_ENV === 'development' ? ["ws:", "wss:"] : [])
      ],
      objectSrc: ["'none'"],
      frameSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));

// Rate limiting with Azure Redis backing
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: NODE_ENV === 'production' ? 100 : 1000,
  message: {
    error: 'Too many requests from this IP, please try again later.',
    retryAfter: '15 minutes'
  },
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => {
    return req.path === '/health' || req.path === '/api/health';
  },
  // Use Redis for distributed rate limiting in production
  store: NODE_ENV === 'production' ? undefined : undefined // TODO: Implement Redis store
});

app.use('/api', limiter);

// CORS configuration for Azure
const corsOptions = {
  origin: NODE_ENV === 'production' 
    ? [
        process.env.CORS_ORIGIN,
        'https://iterativ-analytics.azurewebsites.net',
        'https://iterativ-analytics-staging.azurewebsites.net'
      ].filter(Boolean)
    : true,
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-csrf-token'],
};

app.use(cors(corsOptions));

// Body parsing and compression
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Request logging with Azure Application Insights
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    // Log to Winston
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
    });
    
    // Track in Application Insights
    azureMonitoring.trackDependency(
      'HTTP Request',
      `${req.method} ${req.url}`,
      duration,
      res.statusCode < 400,
      {
        method: req.method,
        url: req.url,
        statusCode: res.statusCode,
        ip: req.ip
      }
    );
    
    // Track metrics
    azureMonitoring.trackMetric('RequestDuration', duration, {
      method: req.method,
      endpoint: req.route?.path || req.url
    });
    
    if (res.statusCode >= 400) {
      azureMonitoring.trackMetric('ErrorRate', 1, {
        statusCode: res.statusCode,
        endpoint: req.route?.path || req.url
      });
    }
  });
  
  next();
});

// Health check endpoint with Azure service status
app.get('/health', async (req, res) => {
  try {
    const dbHealthy = await azureDb.testConnection();
    
    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      environment: NODE_ENV,
      version: process.env.npm_package_version || '1.0.0',
      services: {
        database: dbHealthy ? 'healthy' : 'unhealthy',
        cache: 'healthy', // TODO: Add Redis health check
        openai: 'healthy' // TODO: Add OpenAI health check
      }
    };
    
    const isHealthy = Object.values(health.services).every(status => status === 'healthy');
    
    if (!isHealthy) {
      azureMonitoring.trackEvent('UnhealthyService', health.services);
    }
    
    res.status(isHealthy ? 200 : 503).json(health);
  } catch (error) {
    logger.error('Health check failed:', error);
    azureMonitoring.trackException(error as Error);
    
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: 'Health check failed'
    });
  }
});

// API routes
app.use('/api', azureRoutes);

// Serve static files from the dist directory in production
if (NODE_ENV === 'production') {
  app.use(express.static(resolve(__dirname, '../dist'), {
    maxAge: '1y',
    etag: true,
    lastModified: true,
  }));

  // Handle client-side routing
  app.get('*', (req, res) => {
    res.sendFile(resolve(__dirname, '../dist/index.html'));
  });
}

// Error handling middleware
app.use(notFoundHandler);
app.use(errorHandler);

// Start server with Azure service initialization
const startServer = async () => {
  try {
    await initializeAzureServices();
    
    const server = app.listen(PORT, '0.0.0.0', () => {
      logger.info('Server starting', {
        port: PORT,
        environment: NODE_ENV,
        timestamp: new Date().toISOString()
      });
      
      azureMonitoring.trackEvent('ServerStarted', {
        port: PORT,
        environment: NODE_ENV
      });
    });

    // Graceful shutdown handling
    const shutdown = async (signal: string) => {
      logger.info(`${signal} received, shutting down gracefully`);
      
      server.close(async () => {
        try {
          await azureDb.closeConnection();
          await azureCache.disconnect();
          logger.info('Server closed');
          process.exit(0);
        } catch (error) {
          logger.error('Error during shutdown:', error);
          process.exit(1);
        }
      });
    };

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));

  } catch (error) {
    logger.error('Failed to start server:', error);
    azureMonitoring.trackException(error as Error);
    process.exit(1);
  }
};

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error);
  azureMonitoring.trackException(error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
  azureMonitoring.trackException(reason as Error);
  process.exit(1);
});

// Start the server
startServer();

export default app;