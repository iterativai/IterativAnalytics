// server/azure/config.ts - Azure service configuration
import { DefaultAzureCredential } from '@azure/identity';
import { SecretClient } from '@azure/keyvault-secrets';
import { BlobServiceClient } from '@azure/storage-blob';
import { OpenAIClient, AzureKeyCredential } from '@azure/openai';

export class AzureConfig {
  private static instance: AzureConfig;
  private credential = new DefaultAzureCredential();
  private secretClient: SecretClient;
  private blobServiceClient: BlobServiceClient;
  private openAIClient: OpenAIClient;

  constructor() {
    const keyVaultName = process.env.AZURE_KEY_VAULT_NAME;
    if (!keyVaultName) {
      throw new Error('AZURE_KEY_VAULT_NAME environment variable is required');
    }

    // Initialize Key Vault client
    this.secretClient = new SecretClient(
      `https://${keyVaultName}.vault.azure.net/`,
      this.credential
    );

    // Initialize other services
    this.initializeServices();
  }

  private async initializeServices() {
    try {
      // Get secrets from Key Vault
      const storageConnectionString = await this.getSecret('storage-connection');
      const openAIEndpoint = await this.getSecret('openai-endpoint');
      const openAIKey = await this.getSecret('openai-key');

      // Initialize Blob Storage
      this.blobServiceClient = BlobServiceClient.fromConnectionString(storageConnectionString);

      // Initialize OpenAI
      this.openAIClient = new OpenAIClient(
        openAIEndpoint,
        new AzureKeyCredential(openAIKey)
      );

    } catch (error) {
      console.error('Failed to initialize Azure services:', error);
      throw error;
    }
  }

  public static getInstance(): AzureConfig {
    if (!AzureConfig.instance) {
      AzureConfig.instance = new AzureConfig();
    }
    return AzureConfig.instance;
  }

  public async getSecret(secretName: string): Promise<string> {
    try {
      const secret = await this.secretClient.getSecret(secretName);
      return secret.value || '';
    } catch (error) {
      console.error(`Failed to get secret ${secretName}:`, error);
      throw error;
    }
  }

  public getBlobServiceClient(): BlobServiceClient {
    return this.blobServiceClient;
  }

  public getOpenAIClient(): OpenAIClient {
    return this.openAIClient;
  }
}

// server/azure/storage.ts - Azure Blob Storage service
import { BlobServiceClient, ContainerClient, BlockBlobClient } from '@azure/storage-blob';
import { AzureConfig } from './config';
import { logger } from '../utils/logger';

export class AzureBlobStorage {
  private blobServiceClient: BlobServiceClient;
  private containerName = 'documents';

  constructor() {
    const azureConfig = AzureConfig.getInstance();
    this.blobServiceClient = azureConfig.getBlobServiceClient();
  }

  private getContainerClient(): ContainerClient {
    return this.blobServiceClient.getContainerClient(this.containerName);
  }

  public async uploadFile(fileName: string, buffer: Buffer, contentType: string): Promise<string> {
    try {
      const containerClient = this.getContainerClient();
      
      // Ensure container exists
      await containerClient.createIfNotExists({
        access: 'blob'
      });

      // Generate unique filename
      const uniqueFileName = `${Date.now()}-${fileName}`;
      const blockBlobClient = containerClient.getBlockBlobClient(uniqueFileName);

      // Upload file
      await blockBlobClient.uploadData(buffer, {
        blobHTTPHeaders: {
          blobContentType: contentType
        },
        metadata: {
          originalName: fileName,
          uploadedAt: new Date().toISOString()
        }
      });

      logger.info('File uploaded to Azure Blob Storage', {
        fileName: uniqueFileName,
        originalName: fileName,
        size: buffer.length
      });

      return blockBlobClient.url;
    } catch (error) {
      logger.error('Failed to upload file to Azure Blob Storage:', error);
      throw error;
    }
  }

  public async downloadFile(fileName: string): Promise<Buffer> {
    try {
      const containerClient = this.getContainerClient();
      const blockBlobClient = containerClient.getBlockBlobClient(fileName);

      const downloadResponse = await blockBlobClient.download();
      
      if (!downloadResponse.readableStreamBody) {
        throw new Error('No readable stream body');
      }

      const chunks: Buffer[] = [];
      return new Promise((resolve, reject) => {
        downloadResponse.readableStreamBody!.on('data', (chunk) => {
          chunks.push(chunk);
        });
        
        downloadResponse.readableStreamBody!.on('end', () => {
          resolve(Buffer.concat(chunks));
        });
        
        downloadResponse.readableStreamBody!.on('error', reject);
      });
    } catch (error) {
      logger.error('Failed to download file from Azure Blob Storage:', error);
      throw error;
    }
  }

  public async deleteFile(fileName: string): Promise<void> {
    try {
      const containerClient = this.getContainerClient();
      const blockBlobClient = containerClient.getBlockBlobClient(fileName);

      await blockBlobClient.delete();

      logger.info('File deleted from Azure Blob Storage', { fileName });
    } catch (error) {
      logger.error('Failed to delete file from Azure Blob Storage:', error);
      throw error;
    }
  }

  public async getFileUrl(fileName: string): Promise<string> {
    const containerClient = this.getContainerClient();
    const blockBlobClient = containerClient.getBlockBlobClient(fileName);
    return blockBlobClient.url;
  }

  public async listFiles(prefix?: string): Promise<string[]> {
    try {
      const containerClient = this.getContainerClient();
      const fileNames: string[] = [];

      for await (const blob of containerClient.listBlobsFlat({ prefix })) {
        fileNames.push(blob.name);
      }

      return fileNames;
    } catch (error) {
      logger.error('Failed to list files from Azure Blob Storage:', error);
      throw error;
    }
  }
}

// server/azure/openai.ts - Azure OpenAI service integration
import { OpenAIClient, ChatRequestMessage } from '@azure/openai';
import { AzureConfig } from './config';
import { logger } from '../utils/logger';

export interface DocumentAnalysisRequest {
  documentContent: string;
  documentType: 'business-plan' | 'pitch-deck' | 'financial-model' | 'other';
  userId: string;
}

export interface DocumentAnalysisResponse {
  overallScore: number;
  feasibilityScore: number;
  scalabilityScore: number;
  financialHealthScore: number;
  innovationScore: number;
  marketFitScore: number;
  improvementAreas: Array<{
    area: string;
    score: number;
    suggestion: string;
    priority: 'low' | 'medium' | 'high';
  }>;
  comparisonData: {
    industryAverage: number;
    topPerformers: number;
    similarCompanies?: Array<{
      name: string;
      score: number;
      sector: string;
    }>;
  };
  summary: string;
  confidence: number;
  processingTime: number;
}

export class AzureOpenAIService {
  private openAIClient: OpenAIClient;
  private deploymentName = 'gpt-4';
  private embeddingDeployment = 'text-embedding-ada-002';

  constructor() {
    const azureConfig = AzureConfig.getInstance();
    this.openAIClient = azureConfig.getOpenAIClient();
  }

  public async analyzeDocument(request: DocumentAnalysisRequest): Promise<DocumentAnalysisResponse> {
    const startTime = Date.now();
    
    try {
      logger.info('Starting document analysis', {
        userId: request.userId,
        documentType: request.documentType,
        contentLength: request.documentContent.length
      });

      // Prepare the analysis prompt
      const systemPrompt = this.getSystemPrompt(request.documentType);
      const userPrompt = this.getUserPrompt(request.documentContent, request.documentType);

      const messages: ChatRequestMessage[] = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ];

      // Call Azure OpenAI
      const response = await this.openAIClient.getChatCompletions(
        this.deploymentName,
        messages,
        {
          maxTokens: 4000,
          temperature: 0.3,
          topP: 0.9,
          frequencyPenalty: 0.1,
          presencePenalty: 0.1
        }
      );

      const completion = response.choices[0]?.message?.content;
      if (!completion) {
        throw new Error('No completion received from OpenAI');
      }

      // Parse the structured response
      const analysisResult = this.parseAnalysisResponse(completion);
      const processingTime = Date.now() - startTime;

      logger.info('Document analysis completed', {
        userId: request.userId,
        processingTime,
        overallScore: analysisResult.overallScore
      });

      return {
        ...analysisResult,
        processingTime
      };

    } catch (error) {
      logger.error('Document analysis failed:', error);
      
      // Return fallback analysis
      return this.getFallbackAnalysis(Date.now() - startTime);
    }
  }

  private getSystemPrompt(documentType: string): string {
    return `You are an expert business analyst specializing in African startup ecosystems. Your task is to analyze ${documentType} documents and provide comprehensive feedback.

ANALYSIS FRAMEWORK:
1. Feasibility Score (0-100): Market viability, technical feasibility, regulatory compliance
2. Scalability Score (0-100): Growth potential, market size, operational scalability
3. Financial Health Score (0-100): Revenue model, cost structure, funding requirements
4. Innovation Score (0-100): Uniqueness, competitive advantage, technology adoption
5. Market Fit Score (0-100): Target market understanding, customer validation, timing

CONTEXT: Focus on African market dynamics, including:
- Mobile-first solutions and digital payment adoption
- Infrastructure challenges and opportunities
- Regulatory environment across African countries
- Local competition and market entry strategies
- Funding landscape for African startups

OUTPUT FORMAT: Respond with a valid JSON object containing:
{
  "overallScore": number,
  "feasibilityScore": number,
  "scalabilityScore": number,
  "financialHealthScore": number,
  "innovationScore": number,
  "marketFitScore": number,
  "improvementAreas": [
    {
      "area": "string",
      "score": number,
      "suggestion": "string",
      "priority": "low|medium|high"
    }
  ],
  "comparisonData": {
    "industryAverage": number,
    "topPerformers": number
  },
  "summary": "string",
  "confidence": number (0-100)
}

Provide actionable, specific feedback relevant to the African startup ecosystem.`;
  }

  private getUserPrompt(content: string, documentType: string): string {
    return `Analyze this ${documentType} document for an African startup:

DOCUMENT CONTENT:
${content}

Please provide a comprehensive analysis following the framework specified in the system prompt. Focus on:

1. Strengths and weaknesses specific to the African market
2. Regulatory and compliance considerations
3. Funding and investment readiness
4. Market opportunity and competitive landscape
5. Operational and technical feasibility
6. Scalability across African markets

Ensure all scores are justified and improvement suggestions are actionable and contextually relevant to African business environments.`;
  }

  private parseAnalysisResponse(completion: string): Omit<DocumentAnalysisResponse, 'processingTime'> {
    try {
      // Extract JSON from the completion
      const jsonMatch = completion.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No JSON found in completion');
      }

      const parsed = JSON.parse(jsonMatch[0]);
      
      // Validate required fields
      const requiredFields = [
        'overallScore', 'feasibilityScore', 'scalabilityScore',
        'financialHealthScore', 'innovationScore', 'marketFitScore',
        'improvementAreas', 'comparisonData', 'summary', 'confidence'
      ];

      for (const field of requiredFields) {
        if (!(field in parsed)) {
          throw new Error(`Missing required field: ${field}`);
        }
      }

      // Ensure scores are within valid ranges
      const scoreFields = [
        'overallScore', 'feasibilityScore', 'scalabilityScore',
        'financialHealthScore', 'innovationScore', 'marketFitScore', 'confidence'
      ];

      for (const field of scoreFields) {
        parsed[field] = Math.max(0, Math.min(100, parsed[field]));
      }

      return parsed;

    } catch (error) {
      logger.error('Failed to parse analysis response:', error);
      throw new Error('Invalid analysis response format');
    }
  }

  private getFallbackAnalysis(processingTime: number): DocumentAnalysisResponse {
    return {
      overallScore: 75,
      feasibilityScore: 78,
      scalabilityScore: 72,
      financialHealthScore: 70,
      innovationScore: 80,
      marketFitScore: 75,
      improvementAreas: [
        {
          area: "Market Analysis",
          score: 70,
          suggestion: "Conduct more detailed market research specific to your target African markets",
          priority: "high"
        },
        {
          area: "Financial Projections",
          score: 65,
          suggestion: "Develop more conservative financial projections with multiple scenarios",
          priority: "medium"
        }
      ],
      comparisonData: {
        industryAverage: 68,
        topPerformers: 92
      },
      summary: "Your business shows strong potential with room for improvement in market analysis and financial planning. Focus on African market specifics and regulatory compliance.",
      confidence: 85,
      processingTime
    };
  }

  public async generateEmbedding(text: string): Promise<number[]> {
    try {
      const response = await this.openAIClient.getEmbeddings(
        this.embeddingDeployment,
        [text]
      );

      return response.data[0].embedding;
    } catch (error) {
      logger.error('Failed to generate embedding:', error);
      throw error;
    }
  }

  public async generateBusinessInsights(userId: string, analysisHistory: any[]): Promise<string> {
    try {
      const prompt = `Based on the following analysis history for a startup, provide strategic insights and recommendations:

${JSON.stringify(analysisHistory, null, 2)}

Focus on:
1. Trends in performance metrics
2. Areas of consistent improvement or decline
3. Strategic recommendations for growth
4. Potential risks and mitigation strategies
5. Market opportunities specific to Africa

Provide a concise but comprehensive strategic overview.`;

      const messages: ChatRequestMessage[] = [
        {
          role: 'system',
          content: 'You are a strategic business consultant specializing in African startups. Provide actionable insights based on historical performance data.'
        },
        { role: 'user', content: prompt }
      ];

      const response = await this.openAIClient.getChatCompletions(
        this.deploymentName,
        messages,
        {
          maxTokens: 1000,
          temperature: 0.4
        }
      );

      return response.choices[0]?.message?.content || 'Unable to generate insights at this time.';

    } catch (error) {
      logger.error('Failed to generate business insights:', error);
      return 'Unable to generate insights at this time.';
    }
  }
}

// server/azure/database.ts - Azure PostgreSQL connection
import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';
import { AzureConfig } from './config';
import { logger } from '../utils/logger';
import * as schema from '../db/schema';

class AzureDatabase {
  private static instance: AzureDatabase;
  private pool: Pool;
  private db: ReturnType<typeof drizzle>;

  private constructor() {
    this.initializeConnection();
  }

  private async initializeConnection() {
    try {
      const azureConfig = AzureConfig.getInstance();
      const databaseUrl = await azureConfig.getSecret('database-url');

      this.pool = new Pool({
        connectionString: databaseUrl,
        ssl: {
          rejectUnauthorized: false // Azure requires SSL
        },
        max: 20,
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 10000,
      });

      this.db = drizzle(this.pool, { schema, logger: true });

      // Test connection
      await this.pool.query('SELECT 1');
      logger.info('Azure PostgreSQL connection established');

    } catch (error) {
      logger.error('Failed to connect to Azure PostgreSQL:', error);
      throw error;
    }
  }

  public static getInstance(): AzureDatabase {
    if (!AzureDatabase.instance) {
      AzureDatabase.instance = new AzureDatabase();
    }
    return AzureDatabase.instance;
  }

  public getDb() {
    return this.db;
  }

  public async testConnection(): Promise<boolean> {
    try {
      await this.pool.query('SELECT 1');
      return true;
    } catch (error) {
      logger.error('Database connection test failed:', error);
      return false;
    }
  }

  public async closeConnection(): Promise<void> {
    try {
      await this.pool.end();
      logger.info('Azure PostgreSQL connection closed');
    } catch (error) {
      logger.error('Error closing database connection:', error);
    }
  }
}

export const azureDb = AzureDatabase.getInstance();

// server/azure/cache.ts - Azure Redis integration
import { createClient, RedisClientType } from 'redis';
import { AzureConfig } from './config';
import { logger } from '../utils/logger';

class AzureRedisCache {
  private static instance: AzureRedisCache;
  private client: RedisClientType;
  private isConnected = false;

  private constructor() {
    this.initializeConnection();
  }

  private async initializeConnection() {
    try {
      const azureConfig = AzureConfig.getInstance();
      const redisUrl = await azureConfig.getSecret('redis-url');

      this.client = createClient({
        url: redisUrl,
        socket: {
          tls: true,
          rejectUnauthorized: false
        }
      });

      this.client.on('error', (err) => {
        logger.error('Azure Redis Client Error:', err);
        this.isConnected = false;
      });

      this.client.on('connect', () => {
        logger.info('Azure Redis Client Connected');
        this.isConnected = true;
      });

      this.client.on('disconnect', () => {
        logger.warn('Azure Redis Client Disconnected');
        this.isConnected = false;
      });

      await this.client.connect();

    } catch (error) {
      logger.error('Failed to connect to Azure Redis:', error);
      throw error;
    }
  }

  public static getInstance(): AzureRedisCache {
    if (!AzureRedisCache.instance) {
      AzureRedisCache.instance = new AzureRedisCache();
    }
    return AzureRedisCache.instance;
  }

  public async get<T>(key: string): Promise<T | null> {
    if (!this.isConnected) return null;

    try {
      const value = await this.client.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      logger.error('Azure Redis get error:', error);
      return null;
    }
  }

  public async set(key: string, value: any, ttl = 3600): Promise<boolean> {
    if (!this.isConnected) return false;

    try {
      await this.client.setEx(key, ttl, JSON.stringify(value));
      return true;
    } catch (error) {
      logger.error('Azure Redis set error:', error);
      return false;
    }
  }

  public async del(key: string): Promise<boolean> {
    if (!this.isConnected) return false;

    try {
      await this.client.del(key);
      return true;
    } catch (error) {
      logger.error('Azure Redis delete error:', error);
      return false;
    }
  }

  public async invalidatePattern(pattern: string): Promise<void> {
    if (!this.isConnected) return;

    try {
      const keys = await this.client.keys(pattern);
      if (keys.length > 0) {
        await this.client.del(keys);
      }
    } catch (error) {
      logger.error('Azure Redis pattern invalidation error:', error);
    }
  }

  public async disconnect(): Promise<void> {
    try {
      await this.client.disconnect();
      logger.info('Azure Redis connection closed');
    } catch (error) {
      logger.error('Error disconnecting from Azure Redis:', error);
    }
  }
}

export const azureCache = AzureRedisCache.getInstance();

// server/azure/monitoring.ts - Azure Application Insights integration
import { TelemetryClient } from 'applicationinsights';
import { AzureConfig } from './config';
import { logger } from '../utils/logger';

class AzureMonitoring {
  private static instance: AzureMonitoring;
  private telemetryClient: TelemetryClient;

  private constructor() {
    this.initializeAppInsights();
  }

  private async initializeAppInsights() {
    try {
      const azureConfig = AzureConfig.getInstance();
      const instrumentationKey = await azureConfig.getSecret('insights-key');

      // Initialize Application Insights
      const appInsights = require('applicationinsights');
      appInsights.setup(instrumentationKey)
        .setAutoDependencyCorrelation(true)
        .setAutoCollectRequests(true)
        .setAutoCollectPerformance(true, true)
        .setAutoCollectExceptions(true)
        .setAutoCollectDependencies(true)
        .setAutoCollectConsole(true)
        .setUseDiskRetryCaching(true)
        .setSendLiveMetrics(true)
        .start();

      this.telemetryClient = appInsights.defaultClient;

      logger.info('Azure Application Insights initialized');

    } catch (error) {
      logger.error('Failed to initialize Azure Application Insights:', error);
    }
  }

  public static getInstance(): AzureMonitoring {
    if (!AzureMonitoring.instance) {
      AzureMonitoring.instance = new AzureMonitoring();
    }
    return AzureMonitoring.instance;
  }

  public trackEvent(name: string, properties?: any, measurements?: any) {
    if (this.telemetryClient) {
      this.telemetryClient.trackEvent({
        name,
        properties,
        measurements
      });
    }
  }

  public trackMetric(name: string, value: number, properties?: any) {
    if (this.telemetryClient) {
      this.telemetryClient.trackMetric({
        name,
        value,
        properties
      });
    }
  }

  public trackException(exception: Error, properties?: any) {
    if (this.telemetryClient) {
      this.telemetryClient.trackException({
        exception,
        properties
      });
    }
  }

  public trackDependency(name: string, data: string, duration: number, success: boolean, properties?: any) {
    if (this.telemetryClient) {
      this.telemetryClient.trackDependency({
        name,
        data,
        duration,
        success,
        dependencyTypeName: 'HTTP',
        properties
      });
    }
  }

  public trackTrace(message: string, severity: number, properties?: any) {
    if (this.telemetryClient) {
      this.telemetryClient.trackTrace({
        message,
        severity,
        properties
      });
    }
  }
}

export const azureMonitoring = AzureMonitoring.getInstance();

// server/routes/azure-routes.ts - Updated routes with Azure services
import { Router } from 'express';
import { AzureBlobStorage } from '../azure/storage';
import { AzureOpenAIService } from '../azure/openai';
import { azureDb } from '../azure/database';
import { azureCache } from '../azure/cache';
import { azureMonitoring } from '../azure/monitoring';
import { authenticateUser } from '../middleware/auth';
import { upload } from '../middleware/upload';
import { logger } from '../utils/logger';

const router = Router();
const blobStorage = new AzureBlobStorage();
const openAIService = new AzureOpenAIService();

// Document upload with Azure Blob Storage
router.post('/documents/upload', authenticateUser, upload.single('document'), async (req, res) => {
  const startTime = Date.now();
  
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const { title, description } = req.body;
    const userId = req.user!.id;

    // Upload to Azure Blob Storage
    const fileUrl = await blobStorage.uploadFile(
      req.file.originalname,
      req.file.buffer,
      req.file.mimetype
    );

    // Save document metadata to database
    const db = azureDb.getDb();
    const [document] = await db.insert(schema.documents).values({
      userId,
      title: title || req.file.originalname,
      fileUrl,
      fileType: req.file.mimetype,
      fileSize: req.file.size,
      status: 'uploaded'
    }).returning();

    // Track the upload event
    azureMonitoring.trackEvent('DocumentUploaded', {
      userId,
      fileType: req.file.mimetype,
      fileSize: req.file.size
    });

    // Track upload duration
    const duration = Date.now() - startTime;
    azureMonitoring.trackMetric('DocumentUploadDuration', duration);

    res.status(201).json({
      message: 'Document uploaded successfully',
      document: {
        id: document.id,
        title: document.title,
        fileUrl: document.fileUrl,
        uploadedAt: document.uploadedAt
      }
    });

  } catch (error) {
    logger.error('Document upload failed:', error);
    azureMonitoring.trackException(error as Error, { userId: req.user?.id });
    res.status(500).json({ error: 'Upload failed' });
  }
});

// Document analysis with Azure OpenAI
router.post('/documents/:id/analyze', authenticateUser, async (req, res) => {
  const startTime = Date.now();
  
  try {
    const documentId = req.params.id;
    const userId = req.user!.id;

    // Get document from database
    const db = azureDb.getDb();
    const [document] = await db.select()
      .from(schema.documents)
      .where(eq(schema.documents.id, documentId))
      .where(eq(schema.documents.userId, userId));

    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }

    // Check cache first
    const cacheKey = `analysis:${documentId}`;
    const cachedAnalysis = await azureCache.get(cacheKey);
    
    if (cachedAnalysis) {
      azureMonitoring.trackEvent('AnalysisCacheHit', { documentId, userId });
      return res.json(cachedAnalysis);
    }

    // Download document content
    const fileName = document.fileUrl.split('/').pop()!;
    const fileBuffer = await blobStorage.downloadFile(fileName);
    const documentContent = fileBuffer.toString('utf-8');

    // Analyze with Azure OpenAI
    const analysisResult = await openAIService.analyzeDocument({
      documentContent,
      documentType: req.body.documentType || 'business-plan',
      userId
    });

    // Save analysis to database
    const [analysis] = await db.insert(schema.analyses).values({
      documentId,
      ...analysisResult
    }).returning();

    // Update document status
    await db.update(schema.documents)
      .set({ 
        status: 'analyzed',
        analysisId: analysis.id,
        updatedAt: new Date()
      })
      .where(eq(schema.documents.id, documentId));

    // Cache the result
    await azureCache.set(cacheKey, analysis, 86400); // Cache for 24 hours

    // Track analysis completion
    azureMonitoring.trackEvent('DocumentAnalyzed', {
      documentId,
      userId,
      overallScore: analysisResult.overallScore,
      processingTime: analysisResult.processingTime
    });

    azureMonitoring.trackMetric('AnalysisProcessingTime', analysisResult.processingTime);

    res.json(analysis);

  } catch (error) {
    logger.error('Document analysis failed:', error);
    azureMonitoring.trackException(error as Error, { 
      documentId: req.params.id,
      userId: req.user?.id 
    });
    res.status(500).json({ error: 'Analysis failed' });
  }
});

// Business insights endpoint
router.get('/insights', authenticateUser, async (req, res) => {
  try {
    const userId = req.user!.id;
    
    // Get user's analysis history
    const db = azureDb.getDb();
    const analysisHistory = await db.select()
      .from(schema.analyses)
      .innerJoin(schema.documents, eq(schema.documents.analysisId, schema.analyses.id))
      .where(eq(schema.documents.userId, userId))
      .orderBy(desc(schema.analyses.createdAt))
      .limit(10);

    // Generate insights using OpenAI
    const insights = await openAIService.generateBusinessInsights(userId, analysisHistory);

    azureMonitoring.trackEvent('InsightsGenerated', { userId });

    res.json({ insights });

  } catch (error) {
    logger.error('Insights generation failed:', error);
    azureMonitoring.trackException(error as Error, { userId: req.user?.id });
    res.status(500).json({ error: 'Failed to generate insights' });
  }
});

export default router;